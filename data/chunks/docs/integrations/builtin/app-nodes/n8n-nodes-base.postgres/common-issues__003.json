{
  "source": "docs/integrations/builtin/app-nodes/n8n-nodes-base.postgres/common-issues.md",
  "index": 3,
  "content": "## Dynamically populate SQL `IN` groups with parameters\n\nIn Postgres, you can use the SQL [`IN` comparison construct](https://www.postgresql.org/docs/current/functions-comparisons.html#FUNCTIONS-COMPARISONS-IN-SCALAR) to make comparisons between groups of values:\n\n```sql\nSELECT color, shirt_size FROM shirts WHERE shirt_size IN ('small', 'medium', 'large');\n```\n\nWhile you can use n8n [expressions](/code/expressions.md) in your query to dynamically populate the values in an `IN` group, combining this with [query parameters](/integrations/builtin/app-nodes/n8n-nodes-base.postgres/index.md#use-query-parameters) provides extra protection by automatically sanitizing input.\n\nTo construct an `IN` group query with query parameters:\n\n1. Set the **Operation** to **Execute Query**.\n2. In **Options**, select **Query Parameters**.\n3. Use an expression to select an array from the input data. For example, `{{ $json.input_shirt_sizes }}`.\n4. In the **Query** parameter, write your query with the `IN` construct with an empty set of parentheses. For example:\n\t```sql\n\tSELECT color, shirt_size FROM shirts WHERE shirt_size IN ();\n\t```\n5. Inside of the `IN` parentheses, use an expression to dynamically create index-based placeholders (like `$1`, `$2`, and `$3`) for the number of items in your query parameter array. You can do this by increasing each array index by one since the placeholder variables are 1 indexed:\n\t```sql\n\tSELECT color, shirt_size FROM shirts WHERE shirt_size IN ({{ $json.input_shirt_sizes.map((i, pos) => \"$\" + (pos+1)).join(', ') }});\n\t```\n\nWith this technique, n8n automatically creates the correct number of [prepared statement placeholders](https://www.postgresql.org/docs/current/sql-prepare.html) for the `IN` values according to the number of items in your array."
}